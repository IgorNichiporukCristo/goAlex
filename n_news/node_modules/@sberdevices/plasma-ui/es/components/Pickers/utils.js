import { useEffect, useRef } from 'react';
var sizes = {
  l: {
    scale: [1, 0.8, 0.8],
    offset: -0.15,
    height: 5
  },
  s: {
    scale: [1, 0.75, 0.5],
    offset: 0.35,
    height: 2.875
  },
  xs: {
    scale: [1, 0.8334, 0.5834],
    offset: 0.35,
    height: 2.05
  }
};

var round = function round(n) {
  return Math.round(n * 100) / 100;
}; // 0 - Infinity


var MAX_SLOT = 3; // 0 - 1

var FULL_OPACITY = 1;
var NONE_OPACITY = 0;
export function getOpacity(slot) {
  var absoluteSlot = Math.abs(slot);
  var ceilSlot = Math.ceil(absoluteSlot) || 1; // Ячейка, в которую перемещается элемент
  // Сколько осталось от размера ячкейки, чтобы элемент занял ее полностью (от 1 до 0)

  var progSlot = ceilSlot - absoluteSlot;

  if (absoluteSlot <= 1) {
    var opacityRangeSize = FULL_OPACITY - NONE_OPACITY;
    var opacity = NONE_OPACITY + progSlot * opacityRangeSize;
    return round(opacity);
  }

  return NONE_OPACITY;
}
export function getOffset(slot, size) {
  var absoluteSlot = Math.abs(slot);
  var ceilSlot = Math.ceil(absoluteSlot) || 1; // Ячейка, в которую перемещается элемент
  // Сколько осталось от размера ячкейки, чтобы элемент занял ее полностью (от 1 до 0)

  var progSlot = ceilSlot - absoluteSlot;
  var shift = sizes[size].offset * sizes[size].height / 2; // От середины до 1 ячейки

  if (absoluteSlot <= 1) {
    return round(slot * shift) || 0;
  } // От 1 ячейки до 2


  if (absoluteSlot <= 2) {
    return round(progSlot * shift * Math.sign(slot));
  } // От 2 ячейки


  return round((absoluteSlot - 2) / (ceilSlot - 2) * Math.sign(slot) * -1 * Math.abs(sizes[size].height));
}
export function getScale(slot, size) {
  var absoluteSlot = Math.abs(slot);
  var ceilSlot = Math.ceil(absoluteSlot) || 1; // Ячейка, в которую перемещается элемент
  // Сколько осталось от размера ячкейки, чтобы элемент занял ее полностью (от 1 до 0)

  var progSlot = ceilSlot - absoluteSlot; // От середины до 1 ячейки

  if (absoluteSlot <= 1) {
    return round(progSlot * (sizes[size].scale[0] - sizes[size].scale[1]) + sizes[size].scale[1]);
  } // От 1 ячейки до 2


  if (absoluteSlot <= 2) {
    return round(progSlot * (sizes[size].scale[1] - sizes[size].scale[2]) + sizes[size].scale[2]);
  } // От 2 ячейки


  return round(progSlot * sizes[size].scale[2]);
}
/**
 * Абстрактный просчет стилей в зависимости от слота,
 * не основываясь на реальном элементе списка.
 */

export var getStyles = function getStyles(slot, size) {
  var normalizedSlot = Math.min(Math.abs(slot), MAX_SLOT) * Math.sign(slot);
  var opacity = getOpacity(normalizedSlot);
  var offset = getOffset(normalizedSlot, size);
  var scale = getScale(normalizedSlot, size);
  return {
    wrapper: {
      /*
       * Размер плавно уменьшается с увеличением значения slot
       */
      transform: "scale(".concat(scale, ") translate3d(0,").concat(offset, "rem,0)")
    },
    text: {
      /*
       * Непрозрачность уменьшается с увеличением значения slot
       */
      opacity: "".concat(1 - opacity)
    },
    whiteText: {
      /*
       * Непрозрачность увеличивается с увеличением значения slot
       */
      opacity: "".concat(opacity)
    }
  };
};
/**
 * Малый размер => большой размер
 * Серый текст => белый текст
 */

var scaleCallback = function scaleCallback(size) {
  return function (itemEl, slot) {
    var styles = getStyles(slot, size);

    if (itemEl.children[0] instanceof HTMLElement) {
      var wrapper = itemEl.children[0];
      wrapper.style.transform = styles.wrapper.transform;
      /**
       * Серый текст
       */

      if (wrapper.children[0] instanceof HTMLElement) {
        wrapper.children[0].style.opacity = styles.text.opacity;
      }
      /**
       * Белый текст
       */


      if (wrapper.children[1] instanceof HTMLElement) {
        wrapper.children[1].style.opacity = styles.whiteText.opacity;
      }
    }
  };
};

export var scaleCallbacks = {
  l: /*#__PURE__*/scaleCallback('l'),
  s: /*#__PURE__*/scaleCallback('s'),
  xs: /*#__PURE__*/scaleCallback('xs')
};
/**
 * Сброс стилей
 */

export var scaleResetCallback = function scaleResetCallback(itemEl) {
  if (itemEl.children[0] instanceof HTMLElement) {
    var transformable = itemEl.children[0];
    transformable.style.transform = '';

    if (transformable.children[0] instanceof HTMLElement) {
      transformable.children[0].style.opacity = '';
    }

    if (transformable.children[1] instanceof HTMLElement) {
      transformable.children[1].style.opacity = '';
    }
  }
};
/**
 * Вернет массив с временными компонентами переданной даты.
 */

export var getTimeValues = function getTimeValues(date) {
  return [date.getHours(), date.getMinutes(), date.getSeconds()];
};
/**
 * Вернет массив компонентами даты.
 */

export var getDateValues = function getDateValues(date) {
  return [date.getFullYear(), date.getMonth(), date.getDate()];
};
/**
 * Проверит, изменился ли массив
 */

export var isChanged = function isChanged(oldValues, newValues) {
  if (oldValues === newValues) {
    return false;
  }

  if (oldValues.length !== newValues.length) {
    return true;
  }

  for (var i = 0; i < oldValues.length; i++) {
    if (oldValues[i] !== newValues[i]) {
      return true;
    }
  }

  return false;
};
/**
 * Вернёт нормализованные значения в заданных пределах
 */

export var getNormalizeValues = function getNormalizeValues(getValues, getSeconds) {
  return function (current, min, max) {
    var curValues = getValues(current);
    var minValues = getValues(min);
    var maxValues = getValues(max);
    var curSeconds = getSeconds(curValues);
    var minSeconds = getSeconds(minValues);
    var maxSeconds = getSeconds(maxValues);

    if (curSeconds < minSeconds) {
      return minValues;
    }

    if (curSeconds > maxSeconds) {
      return maxValues;
    }

    return curValues;
  };
};
/**
 * Хук для сохранения предыдущего значения
 */

export var usePreviousValue = function usePreviousValue(value) {
  var ref = useRef();
  useEffect(function () {
    ref.current = value;
  });
  return ref.current;
};
//# sourceMappingURL=utils.js.map