{"version":3,"sources":["../../src/components/Carousel/hooks.tsx"],"names":["useCarouselContext","CarouselContext","useCarouselItem","innerRef","refs","register","unregister","THROTTLE_DEFAULT_MS","DEBOUNCE_DEFAULT_MS","useCarousel","index","axis","detectActive","detectThreshold","scrollAlign","scaleCallback","scaleResetCallback","onScroll","onIndexChange","onDetectActiveItem","animatedScrollByIndex","throttleMs","debounceMs","prevIndex","direction","offset","CarouselItemRefs","scrollRef","trackRef","debouncedOnIndexChange","i","detectActiveItem","current","itemEdge","scrollPos","scrollSize","scrollEdge","prevItems","nextItems","count","items","forEach","itemRef","itemIndex","itemSize","push","itemSlot","Math","abs","window","requestAnimationFrame","length","splice","elem","prItemsRev","reverse","handleScroll","event","toIndex","scrollEl","pos","animated","setTimeout"],"mappings":"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","sourcesContent":["import { useContext, useRef, useMemo, useEffect, useCallback } from 'react';\nimport throttle from 'lodash.throttle';\n\nimport { useDebouncedFunction } from '../../hooks';\n\nimport { CarouselContext } from './CarouselContext';\nimport { CarouselItemRefs } from './CarouselItemRefs';\nimport type { BasicProps, DetectionProps } from './types';\nimport { scrollToPos, getCalculatedPos, getCalculatedOffset, getItemSlot } from './utils';\n\nexport const useCarouselContext = () => useContext(CarouselContext);\n\n/**\n * Хук для передачи рефа айтема в контекст карусели.\n */\nexport function useCarouselItem<T extends HTMLElement | null>() {\n    const innerRef = useRef<T>(null);\n    const { refs } = useCarouselContext();\n\n    useEffect(() => {\n        refs?.register(innerRef);\n        return () => refs?.unregister(innerRef);\n    }, [refs]);\n\n    return innerRef;\n}\n\nconst THROTTLE_DEFAULT_MS = 100;\nconst DEBOUNCE_DEFAULT_MS = 150;\n\nexport const useCarousel = ({\n    index,\n    axis,\n    detectActive = false,\n    detectThreshold = 0.5,\n    scrollAlign = 'center',\n    scaleCallback,\n    scaleResetCallback,\n    onScroll,\n    onIndexChange,\n    onDetectActiveItem,\n    animatedScrollByIndex = false,\n    throttleMs = THROTTLE_DEFAULT_MS,\n    debounceMs = DEBOUNCE_DEFAULT_MS,\n}: BasicProps & Omit<Partial<DetectionProps>, 'detectActive'> & { detectActive?: boolean }) => {\n    const prevIndex = useRef<number | null>(null);\n    const direction = useRef<boolean | null>(null);\n    const offset = useRef(0);\n    const refs = useMemo(() => new CarouselItemRefs(), []);\n    const scrollRef = useRef<HTMLElement | null>(null);\n    const trackRef = useRef<HTMLElement | null>(null);\n\n    /**\n     * Для того, чтобы не спамить изменениями индекса.\n     * Задержка дебаунса слегка больше, чем у тротлинга.\n     * Таким образом, событие срабатывает при завершении скролла.\n     */\n    const debouncedOnIndexChange = useDebouncedFunction((i: number) => onIndexChange?.(i), debounceMs);\n\n    /**\n     * Вычисление центрального элемента.\n     * Подсчет: от 0 до 1, какое количество ширины/высоты\n     * каждого элемента находится по центру скролла.\n     */\n    const detectActiveItem = useCallback(\n        throttle(() => {\n            if (!scrollRef.current || !trackRef.current || !detectActive) {\n                return;\n            }\n\n            /**\n             * Правая (или нижняя для Оу) граница элемента.\n             */\n            let itemEdge = offset.current;\n\n            /**\n             * Смещение (отрицательный или положительный отступ)\n             * и размер карусели (для Ox - ширина, для Oy - высота).\n             */\n            const scrollPos = scrollRef.current[axis === 'x' ? 'scrollLeft' : 'scrollTop'];\n            const scrollSize = scrollRef.current[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];\n\n            /**\n             * Граница скролла (видимой части).\n             * Смещение + размер.\n             */\n            const scrollEdge = scrollPos + scrollSize;\n\n            /**\n             * Элементы перед, после и в видимой части.\n             * перед [ ВИДИМЫЕ ] после\n             */\n            const prevItems: HTMLElement[] = [];\n            const nextItems: HTMLElement[] = [];\n            let count = 0;\n\n            /**\n             * Проходим по всему списку, суммируя ширины элементов,\n             * пока не найдем один элемент, чей центр будет в центре карусели.\n             */\n            refs.items.forEach((itemRef, itemIndex) => {\n                if (!itemRef.current) {\n                    return;\n                }\n\n                /**\n                 * Для Ox - ширина, для Oy - высота.\n                 */\n                const itemSize = itemRef.current[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];\n\n                /**\n                 * Все элементы правее вьюпорта выпадают из процедуры.\n                 * Сравниваем по предыдущему элементу.\n                 * [ ... ] ...|n| <- Левый край элемента за пределами начала видимой части\n                 */\n                if (itemEdge > scrollEdge) {\n                    if (scaleCallback && scaleResetCallback) {\n                        nextItems.push(itemRef.current);\n                    }\n                    return;\n                }\n\n                itemEdge += itemSize;\n\n                /**\n                 * Все элементы левее вьюпорта выпадают из процедуры.\n                 * Сравниваем по текущему элементу.\n                 * Правый край элемента за пределами начала видимой части -> |p|... [ ... ]\n                 */\n                if (scrollPos > itemEdge) {\n                    if (scaleCallback && scaleResetCallback) {\n                        prevItems.push(itemRef.current);\n                    }\n                    return;\n                }\n\n                const itemSlot = getItemSlot(\n                    itemIndex,\n                    itemEdge,\n                    itemSize,\n                    scrollPos,\n                    scrollSize,\n                    scrollAlign,\n                    prevIndex.current || 0,\n                    offset.current,\n                );\n\n                if (itemSlot !== null) {\n                    if (detectThreshold && Math.abs(itemSlot) <= detectThreshold) {\n                        onDetectActiveItem?.(itemIndex);\n                        debouncedOnIndexChange(itemIndex);\n                    }\n\n                    if (scaleCallback) {\n                        scaleCallback(itemRef.current, itemSlot);\n                        /**\n                         * Количество айтемов в видимой части.\n                         */\n                        count++;\n                    }\n                }\n            });\n\n            if (scaleCallback && scaleResetCallback) {\n                window.requestAnimationFrame(() => {\n                    if (direction.current) {\n                        if (nextItems.length) {\n                            nextItems.splice(0, count).forEach((elem) => scaleCallback(elem, count));\n                            if (nextItems.length) {\n                                nextItems.splice(0, count).forEach((elem) => scaleResetCallback(elem));\n                            }\n                        }\n                    } else if (prevItems.length) {\n                        const prItemsRev = prevItems.reverse();\n                        prItemsRev.splice(0, count).forEach((elem) => scaleCallback(elem, count * -1));\n                        if (prItemsRev.length) {\n                            prItemsRev.splice(0, count).forEach((elem) => scaleResetCallback(elem));\n                        }\n                    }\n                });\n            }\n        }, throttleMs),\n        [axis, scrollRef, onIndexChange],\n    );\n\n    /**\n     * Обработчик скролла на DOM-узел.\n     */\n    const handleScroll = useCallback(\n        (event) => {\n            detectActiveItem();\n            onScroll?.(event);\n        },\n        [detectActiveItem, onScroll],\n    );\n\n    /**\n     * Прокрутка до нужной позиции индекса.\n     */\n    const toIndex = useCallback((i: number) => {\n        if (scrollRef.current && trackRef.current && refs.items.length && i >= 0) {\n            scrollToPos({\n                scrollEl: scrollRef.current,\n                pos: getCalculatedPos({\n                    scrollEl: scrollRef.current,\n                    items: refs.items,\n                    axis,\n                    index: i,\n                    offset: offset.current,\n                    scrollAlign,\n                }),\n                axis,\n                /**\n                 * Без анимации при переходе на другой конец списка\n                 */\n                animated:\n                    animatedScrollByIndex &&\n                    (prevIndex.current === null || Math.abs(i - prevIndex.current) !== refs.items.length - 1),\n            });\n            prevIndex.current = i;\n        }\n    }, []);\n\n    /**\n     * Операции на маунте/анмаунте компонента.\n     * Здесь нужно сделать кешируемые вычисления,\n     * Создать слушатели событи и т.п.\n     */\n    useEffect(() => {\n        if (scrollRef.current && trackRef.current) {\n            offset.current = getCalculatedOffset(scrollRef.current, trackRef.current, axis);\n\n            setTimeout(() => {\n                /**\n                 * Прокрутка до начального индекса.\n                 */\n                toIndex(index);\n\n                /**\n                 * Если на момент запуска карусель уже находится на нужной позиции,\n                 * событие скролла не произойдет, не сработает и определение центра,\n                 * необходимо вызвать его вручную.\n                 */\n                detectActiveItem();\n            });\n        }\n    }, []);\n\n    /**\n     * Прокрутка до нужной позиции индекса, если индекс изменился.\n     */\n    useEffect(() => {\n        if (index !== prevIndex.current) {\n            toIndex(index);\n        }\n    }, [index]);\n\n    return {\n        scrollRef,\n        trackRef,\n        refs,\n        handleScroll,\n    };\n};\n"],"file":"hooks.js"}