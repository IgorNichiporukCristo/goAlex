"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCarouselItem = useCarouselItem;
exports.useCarousel = exports.useCarouselContext = void 0;

var _react = /*#__PURE__*/require("react");

var _lodash = /*#__PURE__*/_interopRequireDefault( /*#__PURE__*/require("lodash.throttle"));

var _hooks = /*#__PURE__*/require("../../hooks");

var _CarouselContext = /*#__PURE__*/require("./CarouselContext");

var _CarouselItemRefs = /*#__PURE__*/require("./CarouselItemRefs");

var _utils = /*#__PURE__*/require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var useCarouselContext = function useCarouselContext() {
  return (0, _react.useContext)(_CarouselContext.CarouselContext);
};
/**
 * Хук для передачи рефа айтема в контекст карусели.
 */


exports.useCarouselContext = useCarouselContext;

function useCarouselItem() {
  var innerRef = (0, _react.useRef)(null);

  var _useCarouselContext = useCarouselContext(),
      refs = _useCarouselContext.refs;

  (0, _react.useEffect)(function () {
    refs === null || refs === void 0 ? void 0 : refs.register(innerRef);
    return function () {
      return refs === null || refs === void 0 ? void 0 : refs.unregister(innerRef);
    };
  }, [refs]);
  return innerRef;
}

var THROTTLE_DEFAULT_MS = 100;
var DEBOUNCE_DEFAULT_MS = 150;

var useCarousel = function useCarousel(_ref) {
  var index = _ref.index,
      axis = _ref.axis,
      _ref$detectActive = _ref.detectActive,
      detectActive = _ref$detectActive === void 0 ? false : _ref$detectActive,
      _ref$detectThreshold = _ref.detectThreshold,
      detectThreshold = _ref$detectThreshold === void 0 ? 0.5 : _ref$detectThreshold,
      _ref$scrollAlign = _ref.scrollAlign,
      scrollAlign = _ref$scrollAlign === void 0 ? 'center' : _ref$scrollAlign,
      scaleCallback = _ref.scaleCallback,
      scaleResetCallback = _ref.scaleResetCallback,
      onScroll = _ref.onScroll,
      onIndexChange = _ref.onIndexChange,
      onDetectActiveItem = _ref.onDetectActiveItem,
      _ref$animatedScrollBy = _ref.animatedScrollByIndex,
      animatedScrollByIndex = _ref$animatedScrollBy === void 0 ? false : _ref$animatedScrollBy,
      _ref$throttleMs = _ref.throttleMs,
      throttleMs = _ref$throttleMs === void 0 ? THROTTLE_DEFAULT_MS : _ref$throttleMs,
      _ref$debounceMs = _ref.debounceMs,
      debounceMs = _ref$debounceMs === void 0 ? DEBOUNCE_DEFAULT_MS : _ref$debounceMs;
  var prevIndex = (0, _react.useRef)(null);
  var direction = (0, _react.useRef)(null);
  var offset = (0, _react.useRef)(0);
  var refs = (0, _react.useMemo)(function () {
    return new _CarouselItemRefs.CarouselItemRefs();
  }, []);
  var scrollRef = (0, _react.useRef)(null);
  var trackRef = (0, _react.useRef)(null);
  /**
   * Для того, чтобы не спамить изменениями индекса.
   * Задержка дебаунса слегка больше, чем у тротлинга.
   * Таким образом, событие срабатывает при завершении скролла.
   */

  var debouncedOnIndexChange = (0, _hooks.useDebouncedFunction)(function (i) {
    return onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(i);
  }, debounceMs);
  /**
   * Вычисление центрального элемента.
   * Подсчет: от 0 до 1, какое количество ширины/высоты
   * каждого элемента находится по центру скролла.
   */

  var detectActiveItem = (0, _react.useCallback)((0, _lodash["default"])(function () {
    if (!scrollRef.current || !trackRef.current || !detectActive) {
      return;
    }
    /**
     * Правая (или нижняя для Оу) граница элемента.
     */


    var itemEdge = offset.current;
    /**
     * Смещение (отрицательный или положительный отступ)
     * и размер карусели (для Ox - ширина, для Oy - высота).
     */

    var scrollPos = scrollRef.current[axis === 'x' ? 'scrollLeft' : 'scrollTop'];
    var scrollSize = scrollRef.current[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];
    /**
     * Граница скролла (видимой части).
     * Смещение + размер.
     */

    var scrollEdge = scrollPos + scrollSize;
    /**
     * Элементы перед, после и в видимой части.
     * перед [ ВИДИМЫЕ ] после
     */

    var prevItems = [];
    var nextItems = [];
    var count = 0;
    /**
     * Проходим по всему списку, суммируя ширины элементов,
     * пока не найдем один элемент, чей центр будет в центре карусели.
     */

    refs.items.forEach(function (itemRef, itemIndex) {
      if (!itemRef.current) {
        return;
      }
      /**
       * Для Ox - ширина, для Oy - высота.
       */


      var itemSize = itemRef.current[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];
      /**
       * Все элементы правее вьюпорта выпадают из процедуры.
       * Сравниваем по предыдущему элементу.
       * [ ... ] ...|n| <- Левый край элемента за пределами начала видимой части
       */

      if (itemEdge > scrollEdge) {
        if (scaleCallback && scaleResetCallback) {
          nextItems.push(itemRef.current);
        }

        return;
      }

      itemEdge += itemSize;
      /**
       * Все элементы левее вьюпорта выпадают из процедуры.
       * Сравниваем по текущему элементу.
       * Правый край элемента за пределами начала видимой части -> |p|... [ ... ]
       */

      if (scrollPos > itemEdge) {
        if (scaleCallback && scaleResetCallback) {
          prevItems.push(itemRef.current);
        }

        return;
      }

      var itemSlot = (0, _utils.getItemSlot)(itemIndex, itemEdge, itemSize, scrollPos, scrollSize, scrollAlign, prevIndex.current || 0, offset.current);

      if (itemSlot !== null) {
        if (detectThreshold && Math.abs(itemSlot) <= detectThreshold) {
          onDetectActiveItem === null || onDetectActiveItem === void 0 ? void 0 : onDetectActiveItem(itemIndex);
          debouncedOnIndexChange(itemIndex);
        }

        if (scaleCallback) {
          scaleCallback(itemRef.current, itemSlot);
          /**
           * Количество айтемов в видимой части.
           */

          count++;
        }
      }
    });

    if (scaleCallback && scaleResetCallback) {
      window.requestAnimationFrame(function () {
        if (direction.current) {
          if (nextItems.length) {
            nextItems.splice(0, count).forEach(function (elem) {
              return scaleCallback(elem, count);
            });

            if (nextItems.length) {
              nextItems.splice(0, count).forEach(function (elem) {
                return scaleResetCallback(elem);
              });
            }
          }
        } else if (prevItems.length) {
          var prItemsRev = prevItems.reverse();
          prItemsRev.splice(0, count).forEach(function (elem) {
            return scaleCallback(elem, count * -1);
          });

          if (prItemsRev.length) {
            prItemsRev.splice(0, count).forEach(function (elem) {
              return scaleResetCallback(elem);
            });
          }
        }
      });
    }
  }, throttleMs), [axis, scrollRef, onIndexChange]);
  /**
   * Обработчик скролла на DOM-узел.
   */

  var handleScroll = (0, _react.useCallback)(function (event) {
    detectActiveItem();
    onScroll === null || onScroll === void 0 ? void 0 : onScroll(event);
  }, [detectActiveItem, onScroll]);
  /**
   * Прокрутка до нужной позиции индекса.
   */

  var toIndex = (0, _react.useCallback)(function (i) {
    if (scrollRef.current && trackRef.current && refs.items.length && i >= 0) {
      (0, _utils.scrollToPos)({
        scrollEl: scrollRef.current,
        pos: (0, _utils.getCalculatedPos)({
          scrollEl: scrollRef.current,
          items: refs.items,
          axis: axis,
          index: i,
          offset: offset.current,
          scrollAlign: scrollAlign
        }),
        axis: axis,

        /**
         * Без анимации при переходе на другой конец списка
         */
        animated: animatedScrollByIndex && (prevIndex.current === null || Math.abs(i - prevIndex.current) !== refs.items.length - 1)
      });
      prevIndex.current = i;
    }
  }, []);
  /**
   * Операции на маунте/анмаунте компонента.
   * Здесь нужно сделать кешируемые вычисления,
   * Создать слушатели событи и т.п.
   */

  (0, _react.useEffect)(function () {
    if (scrollRef.current && trackRef.current) {
      offset.current = (0, _utils.getCalculatedOffset)(scrollRef.current, trackRef.current, axis);
      setTimeout(function () {
        /**
         * Прокрутка до начального индекса.
         */
        toIndex(index);
        /**
         * Если на момент запуска карусель уже находится на нужной позиции,
         * событие скролла не произойдет, не сработает и определение центра,
         * необходимо вызвать его вручную.
         */

        detectActiveItem();
      });
    }
  }, []);
  /**
   * Прокрутка до нужной позиции индекса, если индекс изменился.
   */

  (0, _react.useEffect)(function () {
    if (index !== prevIndex.current) {
      toIndex(index);
    }
  }, [index]);
  return {
    scrollRef: scrollRef,
    trackRef: trackRef,
    refs: refs,
    handleScroll: handleScroll
  };
};

exports.useCarousel = useCarousel;
//# sourceMappingURL=hooks.js.map