{"version":3,"sources":["../../../src/components/Carousel/hooks.tsx"],"names":["useContext","useRef","useMemo","useEffect","useCallback","throttle","useDebouncedFunction","CarouselContext","CarouselItemRefs","scrollToPos","getCalculatedPos","getCalculatedOffset","getItemSlot","useCarouselContext","useCarouselItem","innerRef","refs","register","unregister","THROTTLE_DEFAULT_MS","DEBOUNCE_DEFAULT_MS","useCarousel","index","axis","detectActive","detectThreshold","scrollAlign","scaleCallback","scaleResetCallback","onScroll","onIndexChange","onDetectActiveItem","animatedScrollByIndex","throttleMs","debounceMs","prevIndex","direction","offset","scrollRef","trackRef","debouncedOnIndexChange","i","detectActiveItem","current","itemEdge","scrollPos","scrollSize","scrollEdge","prevItems","nextItems","count","items","forEach","itemRef","itemIndex","itemSize","push","itemSlot","Math","abs","window","requestAnimationFrame","length","splice","elem","prItemsRev","reverse","handleScroll","event","toIndex","scrollEl","pos","animated","setTimeout"],"mappings":"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","sourcesContent":["import { useContext, useRef, useMemo, useEffect, useCallback } from 'react';\nimport throttle from 'lodash.throttle';\n\nimport { useDebouncedFunction } from '../../hooks';\n\nimport { CarouselContext } from './CarouselContext';\nimport { CarouselItemRefs } from './CarouselItemRefs';\nimport type { BasicProps, DetectionProps } from './types';\nimport { scrollToPos, getCalculatedPos, getCalculatedOffset, getItemSlot } from './utils';\n\nexport const useCarouselContext = () => useContext(CarouselContext);\n\n/**\n * Хук для передачи рефа айтема в контекст карусели.\n */\nexport function useCarouselItem<T extends HTMLElement | null>() {\n    const innerRef = useRef<T>(null);\n    const { refs } = useCarouselContext();\n\n    useEffect(() => {\n        refs?.register(innerRef);\n        return () => refs?.unregister(innerRef);\n    }, [refs]);\n\n    return innerRef;\n}\n\nconst THROTTLE_DEFAULT_MS = 100;\nconst DEBOUNCE_DEFAULT_MS = 150;\n\nexport const useCarousel = ({\n    index,\n    axis,\n    detectActive = false,\n    detectThreshold = 0.5,\n    scrollAlign = 'center',\n    scaleCallback,\n    scaleResetCallback,\n    onScroll,\n    onIndexChange,\n    onDetectActiveItem,\n    animatedScrollByIndex = false,\n    throttleMs = THROTTLE_DEFAULT_MS,\n    debounceMs = DEBOUNCE_DEFAULT_MS,\n}: BasicProps & Omit<Partial<DetectionProps>, 'detectActive'> & { detectActive?: boolean }) => {\n    const prevIndex = useRef<number | null>(null);\n    const direction = useRef<boolean | null>(null);\n    const offset = useRef(0);\n    const refs = useMemo(() => new CarouselItemRefs(), []);\n    const scrollRef = useRef<HTMLElement | null>(null);\n    const trackRef = useRef<HTMLElement | null>(null);\n\n    /**\n     * Для того, чтобы не спамить изменениями индекса.\n     * Задержка дебаунса слегка больше, чем у тротлинга.\n     * Таким образом, событие срабатывает при завершении скролла.\n     */\n    const debouncedOnIndexChange = useDebouncedFunction((i: number) => onIndexChange?.(i), debounceMs);\n\n    /**\n     * Вычисление центрального элемента.\n     * Подсчет: от 0 до 1, какое количество ширины/высоты\n     * каждого элемента находится по центру скролла.\n     */\n    const detectActiveItem = useCallback(\n        throttle(() => {\n            if (!scrollRef.current || !trackRef.current || !detectActive) {\n                return;\n            }\n\n            /**\n             * Правая (или нижняя для Оу) граница элемента.\n             */\n            let itemEdge = offset.current;\n\n            /**\n             * Смещение (отрицательный или положительный отступ)\n             * и размер карусели (для Ox - ширина, для Oy - высота).\n             */\n            const scrollPos = scrollRef.current[axis === 'x' ? 'scrollLeft' : 'scrollTop'];\n            const scrollSize = scrollRef.current[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];\n\n            /**\n             * Граница скролла (видимой части).\n             * Смещение + размер.\n             */\n            const scrollEdge = scrollPos + scrollSize;\n\n            /**\n             * Элементы перед, после и в видимой части.\n             * перед [ ВИДИМЫЕ ] после\n             */\n            const prevItems: HTMLElement[] = [];\n            const nextItems: HTMLElement[] = [];\n            let count = 0;\n\n            /**\n             * Проходим по всему списку, суммируя ширины элементов,\n             * пока не найдем один элемент, чей центр будет в центре карусели.\n             */\n            refs.items.forEach((itemRef, itemIndex) => {\n                if (!itemRef.current) {\n                    return;\n                }\n\n                /**\n                 * Для Ox - ширина, для Oy - высота.\n                 */\n                const itemSize = itemRef.current[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];\n\n                /**\n                 * Все элементы правее вьюпорта выпадают из процедуры.\n                 * Сравниваем по предыдущему элементу.\n                 * [ ... ] ...|n| <- Левый край элемента за пределами начала видимой части\n                 */\n                if (itemEdge > scrollEdge) {\n                    if (scaleCallback && scaleResetCallback) {\n                        nextItems.push(itemRef.current);\n                    }\n                    return;\n                }\n\n                itemEdge += itemSize;\n\n                /**\n                 * Все элементы левее вьюпорта выпадают из процедуры.\n                 * Сравниваем по текущему элементу.\n                 * Правый край элемента за пределами начала видимой части -> |p|... [ ... ]\n                 */\n                if (scrollPos > itemEdge) {\n                    if (scaleCallback && scaleResetCallback) {\n                        prevItems.push(itemRef.current);\n                    }\n                    return;\n                }\n\n                const itemSlot = getItemSlot(\n                    itemIndex,\n                    itemEdge,\n                    itemSize,\n                    scrollPos,\n                    scrollSize,\n                    scrollAlign,\n                    prevIndex.current || 0,\n                    offset.current,\n                );\n\n                if (itemSlot !== null) {\n                    if (detectThreshold && Math.abs(itemSlot) <= detectThreshold) {\n                        onDetectActiveItem?.(itemIndex);\n                        debouncedOnIndexChange(itemIndex);\n                    }\n\n                    if (scaleCallback) {\n                        scaleCallback(itemRef.current, itemSlot);\n                        /**\n                         * Количество айтемов в видимой части.\n                         */\n                        count++;\n                    }\n                }\n            });\n\n            if (scaleCallback && scaleResetCallback) {\n                window.requestAnimationFrame(() => {\n                    if (direction.current) {\n                        if (nextItems.length) {\n                            nextItems.splice(0, count).forEach((elem) => scaleCallback(elem, count));\n                            if (nextItems.length) {\n                                nextItems.splice(0, count).forEach((elem) => scaleResetCallback(elem));\n                            }\n                        }\n                    } else if (prevItems.length) {\n                        const prItemsRev = prevItems.reverse();\n                        prItemsRev.splice(0, count).forEach((elem) => scaleCallback(elem, count * -1));\n                        if (prItemsRev.length) {\n                            prItemsRev.splice(0, count).forEach((elem) => scaleResetCallback(elem));\n                        }\n                    }\n                });\n            }\n        }, throttleMs),\n        [axis, scrollRef, onIndexChange],\n    );\n\n    /**\n     * Обработчик скролла на DOM-узел.\n     */\n    const handleScroll = useCallback(\n        (event) => {\n            detectActiveItem();\n            onScroll?.(event);\n        },\n        [detectActiveItem, onScroll],\n    );\n\n    /**\n     * Прокрутка до нужной позиции индекса.\n     */\n    const toIndex = useCallback((i: number) => {\n        if (scrollRef.current && trackRef.current && refs.items.length && i >= 0) {\n            scrollToPos({\n                scrollEl: scrollRef.current,\n                pos: getCalculatedPos({\n                    scrollEl: scrollRef.current,\n                    items: refs.items,\n                    axis,\n                    index: i,\n                    offset: offset.current,\n                    scrollAlign,\n                }),\n                axis,\n                /**\n                 * Без анимации при переходе на другой конец списка\n                 */\n                animated:\n                    animatedScrollByIndex &&\n                    (prevIndex.current === null || Math.abs(i - prevIndex.current) !== refs.items.length - 1),\n            });\n            prevIndex.current = i;\n        }\n    }, []);\n\n    /**\n     * Операции на маунте/анмаунте компонента.\n     * Здесь нужно сделать кешируемые вычисления,\n     * Создать слушатели событи и т.п.\n     */\n    useEffect(() => {\n        if (scrollRef.current && trackRef.current) {\n            offset.current = getCalculatedOffset(scrollRef.current, trackRef.current, axis);\n\n            setTimeout(() => {\n                /**\n                 * Прокрутка до начального индекса.\n                 */\n                toIndex(index);\n\n                /**\n                 * Если на момент запуска карусель уже находится на нужной позиции,\n                 * событие скролла не произойдет, не сработает и определение центра,\n                 * необходимо вызвать его вручную.\n                 */\n                detectActiveItem();\n            });\n        }\n    }, []);\n\n    /**\n     * Прокрутка до нужной позиции индекса, если индекс изменился.\n     */\n    useEffect(() => {\n        if (index !== prevIndex.current) {\n            toIndex(index);\n        }\n    }, [index]);\n\n    return {\n        scrollRef,\n        trackRef,\n        refs,\n        handleScroll,\n    };\n};\n"],"file":"hooks.js"}