{"version":3,"sources":["../../../src/components/Carousel/utils.ts"],"names":["animatedScrollToX","animatedScrollToY","positionModByScrollAlign","scrollAlign","position","carouselSize","itemSize","offset","scrollStart","axis","inaccuracy","paddingOffset","getCalculatedPos","scrollEl","items","index","i","current","offsetWidth","offsetHeight","scrollLeft","scrollTop","getCalculatedOffset","trackEl","paddingProp","parseInt","getComputedStyle","scrollToPos","pos","animated","duration","timingFunction","Math","abs","scrollTo","left","top","round","n","getItemSlot","itemIndex","itemEnd","scrollSize","prevIndex","scrollEnd","scrollCenter","itemCenter","prevStart","prevEnd","prevVisible"],"mappings":"AAEA,SAASA,iBAAT,EAA4BC,iBAA5B,QAAqE,aAArE;;AAIA,IAAMC,wBAAwB,GAAG,SAA3BA,wBAA2B,OAgB3B;AAAA,MAfFC,WAeE,QAfFA,WAeE;AAAA,MAdFC,QAcE,QAdFA,QAcE;AAAA,MAbFC,YAaE,QAbFA,YAaE;AAAA,MAZFC,QAYE,QAZFA,QAYE;AAAA,MAXFC,MAWE,QAXFA,MAWE;AAAA,MAVFC,WAUE,QAVFA,WAUE;AAAA,MATFC,IASE,QATFA,IASE;;AACF,MAAIN,WAAW,KAAK,OAApB,EAA6B;AACzB,QAAMO,UAAU,GAAG,CAAnB;AACA,QAAMC,aAAa,GAAGF,IAAI,KAAK,GAAT,GAAeF,MAAM,GAAGD,QAAQ,GAAG,CAApB,GAAwBI,UAAvC,GAAoD,CAA1E;AACA,WAAON,QAAQ,GAAGO,aAAlB;AACH;;AACD,MAAIR,WAAW,KAAK,QAApB,EAA8B;AAC1B,WAAOC,QAAQ,GAAGC,YAAY,GAAG,CAA1B,GAA8BC,QAAQ,GAAG,CAAhD;AACH;;AACD,MAAIH,WAAW,KAAK,KAApB,EAA2B;AACvB,WAAOC,QAAQ,GAAGC,YAAX,GAA0BC,QAA1B,GAAqCC,MAA5C;AACH;;AACD,MAAIJ,WAAW,KAAK,iBAApB,EAAuC;AACnC,QAAIC,QAAQ,IAAII,WAAW,GAAGH,YAAd,GAA6BC,QAA7C,EAAuD;AACnD,aAAOF,QAAQ,GAAGC,YAAX,GAA0BC,QAA1B,GAAqCC,MAA5C;AACH;;AACD,QAAIH,QAAQ,GAAGI,WAAf,EAA4B;AACxB,aAAOA,WAAP;AACH;AACJ;;AACD,SAAOJ,QAAP;AACH,CArCD;AAuCA;AACA;AACA;;;AACA,OAAO,IAAMQ,gBAAgB,GAAG,SAAnBA,gBAAmB,QAc1B;AAAA,MAbFC,QAaE,SAbFA,QAaE;AAAA,MAZFC,KAYE,SAZFA,KAYE;AAAA,MAXFL,IAWE,SAXFA,IAWE;AAAA,MAVFM,KAUE,SAVFA,KAUE;AAAA,MATFR,MASE,SATFA,MASE;AAAA,MARFJ,WAQE,SARFA,WAQE;AACF,MAAIC,QAAQ,GAAGD,WAAW,KAAK,QAAhB,GAA2BI,MAA3B,GAAoC,CAAnD;AACA,MAAIF,YAAJ;AACA,MAAIC,QAAJ;AACA,MAAIE,WAAJ;;AAEA,MAAI,CAACM,KAAK,CAACC,KAAD,CAAV,EAAmB;AACf,WAAOX,QAAP;AACH;;AAED,OAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAApB,EAA2BC,CAAC,EAA5B,EAAgC;AAC5B,QAAIP,IAAI,KAAK,GAAb,EAAkB;AAAA;;AACdL,MAAAA,QAAQ,IAAI,qBAAAU,KAAK,CAACE,CAAD,CAAL,CAASC,OAAT,sEAAkBC,WAAlB,KAAiC,CAA7C;AACH,KAFD,MAEO;AAAA;;AACHd,MAAAA,QAAQ,IAAI,sBAAAU,KAAK,CAACE,CAAD,CAAL,CAASC,OAAT,wEAAkBE,YAAlB,KAAkC,CAA9C;AACH;AACJ;;AAED,MAAIV,IAAI,KAAK,GAAb,EAAkB;AAAA;;AACdJ,IAAAA,YAAY,GAAGQ,QAAQ,CAACK,WAAxB;AACAZ,IAAAA,QAAQ,GAAG,yBAAAQ,KAAK,CAACC,KAAD,CAAL,CAAaE,OAAb,8EAAsBC,WAAtB,KAAqC,CAAhD;AACAV,IAAAA,WAAW,GAAGK,QAAQ,CAACO,UAAvB;AACH,GAJD,MAIO;AAAA;;AACHf,IAAAA,YAAY,GAAGQ,QAAQ,CAACM,YAAxB;AACAb,IAAAA,QAAQ,GAAG,0BAAAQ,KAAK,CAACC,KAAD,CAAL,CAAaE,OAAb,gFAAsBE,YAAtB,KAAsC,CAAjD;AACAX,IAAAA,WAAW,GAAGK,QAAQ,CAACQ,SAAvB;AACH;;AAED,SAAOnB,wBAAwB,CAAC;AAC5BC,IAAAA,WAAW,EAAXA,WAD4B;AAE5BC,IAAAA,QAAQ,EAARA,QAF4B;AAG5BC,IAAAA,YAAY,EAAZA,YAH4B;AAI5BC,IAAAA,QAAQ,EAARA,QAJ4B;AAK5BC,IAAAA,MAAM,EAANA,MAL4B;AAM5BC,IAAAA,WAAW,EAAXA,WAN4B;AAO5BC,IAAAA,IAAI,EAAJA;AAP4B,GAAD,CAA/B;AASH,CAnDM;AAqDP;AACA;AACA;;AACA,OAAO,IAAMa,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACT,QAAD,EAAoBU,OAApB,EAAsCd,IAAtC,EAA2D;AAC1F,MAAMe,WAAW,GAAGf,IAAI,KAAK,GAAT,GAAe,aAAf,GAA+B,YAAnD;AACA,SAAOgB,QAAQ,CAACC,gBAAgB,CAACb,QAAD,CAAhB,CAA2BW,WAA3B,CAAD,EAA0C,EAA1C,CAAR,GAAwDC,QAAQ,CAACC,gBAAgB,CAACH,OAAD,CAAhB,CAA0BC,WAA1B,CAAD,EAAyC,EAAzC,CAAvE;AACH,CAHM;AAKP;AACA;AACA;;AACA,OAAO,IAAMG,WAAW,GAAG,SAAdA,WAAc,QAcrB;AAAA,MAbFd,QAaE,SAbFA,QAaE;AAAA,MAZFe,GAYE,SAZFA,GAYE;AAAA,MAXFnB,IAWE,SAXFA,IAWE;AAAA,MAVFoB,QAUE,SAVFA,QAUE;AAAA,MATFC,QASE,SATFA,QASE;AAAA,MARFC,cAQE,SARFA,cAQE;;AACF,MAAItB,IAAI,KAAK,GAAT,IAAgBuB,IAAI,CAACC,GAAL,CAASL,GAAG,GAAGf,QAAQ,CAACO,UAAxB,IAAsC,CAA1D,EAA6D;AACzD,QAAIS,QAAJ,EAAc;AACV7B,MAAAA,iBAAiB,CAACa,QAAD,EAAWe,GAAX,EAAgBE,QAAhB,EAA0BC,cAA1B,CAAjB;AACH,KAFD,MAEO;AACHlB,MAAAA,QAAQ,CAACqB,QAAT,CAAkB;AAAEC,QAAAA,IAAI,EAAEP;AAAR,OAAlB;AACH;AACJ;;AACD,MAAInB,IAAI,KAAK,GAAT,IAAgBuB,IAAI,CAACC,GAAL,CAASL,GAAG,GAAGf,QAAQ,CAACQ,SAAxB,IAAqC,CAAzD,EAA4D;AACxD,QAAIQ,QAAJ,EAAc;AACV5B,MAAAA,iBAAiB,CAACY,QAAD,EAAWe,GAAX,EAAgBE,QAAhB,EAA0BC,cAA1B,CAAjB;AACH,KAFD,MAEO;AACHlB,MAAAA,QAAQ,CAACqB,QAAT,CAAkB;AAAEE,QAAAA,GAAG,EAAER;AAAP,OAAlB;AACH;AACJ;AACJ,CA7BM;;AA+BP,IAAMS,KAAK,GAAG,SAARA,KAAQ,CAACC,CAAD;AAAA,SAAeN,IAAI,CAACK,KAAL,CAAWC,CAAC,GAAG,GAAf,IAAsB,GAArC;AAAA,CAAd;AAEA;AACA;AACA;AACA;;;AACA,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAc,CACvBC,SADuB,EAEvBC,OAFuB,EAGvBnC,QAHuB,EAIvBE,WAJuB,EAKvBkC,UALuB,EAMvBvC,WANuB,EAStB;AAAA,MAFDwC,SAEC,uEAFW,CAEX;AAAA,MADDpC,MACC,uEADQ,CACR;;AACD;AACJ;AACA;AACA;AACI,MAAMqC,SAAS,GAAGpC,WAAW,GAAGkC,UAAhC;AACA,MAAMG,YAAY,GAAGrC,WAAW,GAAGkC,UAAU,GAAG,CAAhD;AACA,MAAMI,UAAU,GAAGL,OAAO,GAAGnC,QAAQ,GAAG,CAAxC;;AAEA,MAAIH,WAAW,KAAK,QAApB,EAA8B;AAC1B,WAAOkC,KAAK,CAAC,CAACS,UAAU,GAAGD,YAAd,IAA8BvC,QAA/B,CAAZ;AACH;;AACD,MAAIH,WAAW,KAAK,OAApB,EAA6B;AACzB,WAAOkC,KAAK,CAAC,CAACI,OAAO,GAAGnC,QAAV,GAAqBE,WAAtB,IAAqCF,QAAtC,CAAZ;AACH;;AACD,MAAIH,WAAW,KAAK,KAApB,EAA2B;AACvB,WAAOkC,KAAK,CAAC,CAACI,OAAO,IAAIC,UAAU,GAAGlC,WAAjB,CAAR,IAAyCF,QAA1C,CAAZ;AACH;;AACD,MAAIH,WAAW,KAAK,iBAApB,EAAuC;AACnC,QAAM4C,SAAS,GAAGxC,MAAM,GAAGD,QAAQ,GAAGqC,SAAtC;AACA,QAAMK,OAAO,GAAGD,SAAS,GAAGzC,QAA5B;AACA,QAAM2C,WAAW,GAAGD,OAAO,GAAGxC,WAAV,IAAyBuC,SAAS,GAAGH,SAAzD;;AAEA,QAAI,CAACK,WAAL,EAAkB;AACd,UAAIN,SAAS,GAAGH,SAAhB,EAA2B;AACvB,eAAOH,KAAK,CAAC,CAACI,OAAO,IAAIC,UAAU,GAAGlC,WAAjB,CAAR,IAAyCF,QAA1C,CAAZ;AACH;;AACD,aAAO+B,KAAK,CAAC,CAACI,OAAO,GAAGnC,QAAV,GAAqBE,WAAtB,IAAqCF,QAAtC,CAAZ;AACH;AACJ;;AACD,SAAO,IAAP;AACH,CAxCM","sourcesContent":["import { MutableRefObject } from 'react';\n\nimport { animatedScrollToX, animatedScrollToY, TimingFunction } from '../../utils';\n\nimport { ScrollAxis, ScrollAlign } from './types';\n\nconst positionModByScrollAlign = ({\n    scrollAlign,\n    position,\n    carouselSize,\n    itemSize,\n    offset,\n    scrollStart,\n    axis,\n}: {\n    scrollAlign: ScrollAlign;\n    position: number;\n    carouselSize: number;\n    itemSize: number;\n    offset: number;\n    scrollStart: number;\n    axis: ScrollAxis;\n}) => {\n    if (scrollAlign === 'start') {\n        const inaccuracy = 1;\n        const paddingOffset = axis === 'y' ? offset - itemSize / 2 + inaccuracy : 0;\n        return position + paddingOffset;\n    }\n    if (scrollAlign === 'center') {\n        return position - carouselSize / 2 + itemSize / 2;\n    }\n    if (scrollAlign === 'end') {\n        return position - carouselSize + itemSize + offset;\n    }\n    if (scrollAlign === 'activeDirection') {\n        if (position >= scrollStart + carouselSize - itemSize) {\n            return position - carouselSize + itemSize + offset;\n        }\n        if (position > scrollStart) {\n            return scrollStart;\n        }\n    }\n    return position;\n};\n\n/**\n * Подсчет скролла до переданного индекса.\n */\nexport const getCalculatedPos = ({\n    scrollEl,\n    items,\n    axis,\n    index,\n    offset,\n    scrollAlign,\n}: {\n    scrollEl: HTMLElement;\n    items: MutableRefObject<HTMLElement | null>[];\n    axis: ScrollAxis;\n    index: number;\n    offset: number;\n    scrollAlign: ScrollAlign;\n}) => {\n    let position = scrollAlign === 'center' ? offset : 0;\n    let carouselSize;\n    let itemSize;\n    let scrollStart;\n\n    if (!items[index]) {\n        return position;\n    }\n\n    for (let i = 0; i < index; i++) {\n        if (axis === 'x') {\n            position += items[i].current?.offsetWidth || 0;\n        } else {\n            position += items[i].current?.offsetHeight || 0;\n        }\n    }\n\n    if (axis === 'x') {\n        carouselSize = scrollEl.offsetWidth;\n        itemSize = items[index].current?.offsetWidth || 0;\n        scrollStart = scrollEl.scrollLeft;\n    } else {\n        carouselSize = scrollEl.offsetHeight;\n        itemSize = items[index].current?.offsetHeight || 0;\n        scrollStart = scrollEl.scrollTop;\n    }\n\n    return positionModByScrollAlign({\n        scrollAlign,\n        position,\n        carouselSize,\n        itemSize,\n        offset,\n        scrollStart,\n        axis,\n    });\n};\n\n/**\n * Подсчет смещения из-за паддингов.\n */\nexport const getCalculatedOffset = (scrollEl: Element, trackEl: Element, axis: ScrollAxis) => {\n    const paddingProp = axis === 'x' ? 'paddingLeft' : 'paddingTop';\n    return parseInt(getComputedStyle(scrollEl)[paddingProp], 10) + parseInt(getComputedStyle(trackEl)[paddingProp], 10);\n};\n\n/**\n * Прокрутка к указанной позиции с анимацией или без.\n */\nexport const scrollToPos = ({\n    scrollEl,\n    pos,\n    axis,\n    animated,\n    duration,\n    timingFunction,\n}: {\n    scrollEl: HTMLElement;\n    pos: number;\n    axis: ScrollAxis;\n    animated?: boolean;\n    duration?: number;\n    timingFunction?: TimingFunction;\n}) => {\n    if (axis === 'x' && Math.abs(pos - scrollEl.scrollLeft) > 1) {\n        if (animated) {\n            animatedScrollToX(scrollEl, pos, duration, timingFunction);\n        } else {\n            scrollEl.scrollTo({ left: pos });\n        }\n    }\n    if (axis === 'y' && Math.abs(pos - scrollEl.scrollTop) > 1) {\n        if (animated) {\n            animatedScrollToY(scrollEl, pos, duration, timingFunction);\n        } else {\n            scrollEl.scrollTo({ top: pos });\n        }\n    }\n};\n\nconst round = (n: number) => Math.round(n * 100) / 100;\n\n/**\n * Получить позицию (слот) айтема в каруселе.\n * Каждый айтем имеет свой слот относительно вьюпорта карусели.\n */\nexport const getItemSlot = (\n    itemIndex: number,\n    itemEnd: number,\n    itemSize: number,\n    scrollStart: number,\n    scrollSize: number,\n    scrollAlign: ScrollAlign,\n    prevIndex = 0,\n    offset = 0,\n) => {\n    /**\n     * Граница и центр скролла (видимой части).\n     * Смещение + размер.\n     */\n    const scrollEnd = scrollStart + scrollSize;\n    const scrollCenter = scrollStart + scrollSize / 2;\n    const itemCenter = itemEnd - itemSize / 2;\n\n    if (scrollAlign === 'center') {\n        return round((itemCenter - scrollCenter) / itemSize);\n    }\n    if (scrollAlign === 'start') {\n        return round((itemEnd - itemSize - scrollStart) / itemSize);\n    }\n    if (scrollAlign === 'end') {\n        return round((itemEnd - (scrollSize + scrollStart)) / itemSize);\n    }\n    if (scrollAlign === 'activeDirection') {\n        const prevStart = offset + itemSize * prevIndex;\n        const prevEnd = prevStart + itemSize;\n        const prevVisible = prevEnd > scrollStart && prevStart < scrollEnd;\n\n        if (!prevVisible) {\n            if (prevIndex < itemIndex) {\n                return round((itemEnd - (scrollSize + scrollStart)) / itemSize);\n            }\n            return round((itemEnd - itemSize - scrollStart) / itemSize);\n        }\n    }\n    return null;\n};\n"],"file":"utils.js"}