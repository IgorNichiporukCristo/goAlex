import { animatedScrollToX, animatedScrollToY } from '../../utils';

var positionModByScrollAlign = function positionModByScrollAlign(_ref) {
  var scrollAlign = _ref.scrollAlign,
      position = _ref.position,
      carouselSize = _ref.carouselSize,
      itemSize = _ref.itemSize,
      offset = _ref.offset,
      scrollStart = _ref.scrollStart,
      axis = _ref.axis;

  if (scrollAlign === 'start') {
    var inaccuracy = 1;
    var paddingOffset = axis === 'y' ? offset - itemSize / 2 + inaccuracy : 0;
    return position + paddingOffset;
  }

  if (scrollAlign === 'center') {
    return position - carouselSize / 2 + itemSize / 2;
  }

  if (scrollAlign === 'end') {
    return position - carouselSize + itemSize + offset;
  }

  if (scrollAlign === 'activeDirection') {
    if (position >= scrollStart + carouselSize - itemSize) {
      return position - carouselSize + itemSize + offset;
    }

    if (position > scrollStart) {
      return scrollStart;
    }
  }

  return position;
};
/**
 * Подсчет скролла до переданного индекса.
 */


export var getCalculatedPos = function getCalculatedPos(_ref2) {
  var scrollEl = _ref2.scrollEl,
      items = _ref2.items,
      axis = _ref2.axis,
      index = _ref2.index,
      offset = _ref2.offset,
      scrollAlign = _ref2.scrollAlign;
  var position = scrollAlign === 'center' ? offset : 0;
  var carouselSize;
  var itemSize;
  var scrollStart;

  if (!items[index]) {
    return position;
  }

  for (var i = 0; i < index; i++) {
    if (axis === 'x') {
      var _items$i$current;

      position += ((_items$i$current = items[i].current) === null || _items$i$current === void 0 ? void 0 : _items$i$current.offsetWidth) || 0;
    } else {
      var _items$i$current2;

      position += ((_items$i$current2 = items[i].current) === null || _items$i$current2 === void 0 ? void 0 : _items$i$current2.offsetHeight) || 0;
    }
  }

  if (axis === 'x') {
    var _items$index$current;

    carouselSize = scrollEl.offsetWidth;
    itemSize = ((_items$index$current = items[index].current) === null || _items$index$current === void 0 ? void 0 : _items$index$current.offsetWidth) || 0;
    scrollStart = scrollEl.scrollLeft;
  } else {
    var _items$index$current2;

    carouselSize = scrollEl.offsetHeight;
    itemSize = ((_items$index$current2 = items[index].current) === null || _items$index$current2 === void 0 ? void 0 : _items$index$current2.offsetHeight) || 0;
    scrollStart = scrollEl.scrollTop;
  }

  return positionModByScrollAlign({
    scrollAlign: scrollAlign,
    position: position,
    carouselSize: carouselSize,
    itemSize: itemSize,
    offset: offset,
    scrollStart: scrollStart,
    axis: axis
  });
};
/**
 * Подсчет смещения из-за паддингов.
 */

export var getCalculatedOffset = function getCalculatedOffset(scrollEl, trackEl, axis) {
  var paddingProp = axis === 'x' ? 'paddingLeft' : 'paddingTop';
  return parseInt(getComputedStyle(scrollEl)[paddingProp], 10) + parseInt(getComputedStyle(trackEl)[paddingProp], 10);
};
/**
 * Прокрутка к указанной позиции с анимацией или без.
 */

export var scrollToPos = function scrollToPos(_ref3) {
  var scrollEl = _ref3.scrollEl,
      pos = _ref3.pos,
      axis = _ref3.axis,
      animated = _ref3.animated,
      duration = _ref3.duration,
      timingFunction = _ref3.timingFunction;

  if (axis === 'x' && Math.abs(pos - scrollEl.scrollLeft) > 1) {
    if (animated) {
      animatedScrollToX(scrollEl, pos, duration, timingFunction);
    } else {
      scrollEl.scrollTo({
        left: pos
      });
    }
  }

  if (axis === 'y' && Math.abs(pos - scrollEl.scrollTop) > 1) {
    if (animated) {
      animatedScrollToY(scrollEl, pos, duration, timingFunction);
    } else {
      scrollEl.scrollTo({
        top: pos
      });
    }
  }
};

var round = function round(n) {
  return Math.round(n * 100) / 100;
};
/**
 * Получить позицию (слот) айтема в каруселе.
 * Каждый айтем имеет свой слот относительно вьюпорта карусели.
 */


export var getItemSlot = function getItemSlot(itemIndex, itemEnd, itemSize, scrollStart, scrollSize, scrollAlign) {
  var prevIndex = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
  var offset = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;

  /**
   * Граница и центр скролла (видимой части).
   * Смещение + размер.
   */
  var scrollEnd = scrollStart + scrollSize;
  var scrollCenter = scrollStart + scrollSize / 2;
  var itemCenter = itemEnd - itemSize / 2;

  if (scrollAlign === 'center') {
    return round((itemCenter - scrollCenter) / itemSize);
  }

  if (scrollAlign === 'start') {
    return round((itemEnd - itemSize - scrollStart) / itemSize);
  }

  if (scrollAlign === 'end') {
    return round((itemEnd - (scrollSize + scrollStart)) / itemSize);
  }

  if (scrollAlign === 'activeDirection') {
    var prevStart = offset + itemSize * prevIndex;
    var prevEnd = prevStart + itemSize;
    var prevVisible = prevEnd > scrollStart && prevStart < scrollEnd;

    if (!prevVisible) {
      if (prevIndex < itemIndex) {
        return round((itemEnd - (scrollSize + scrollStart)) / itemSize);
      }

      return round((itemEnd - itemSize - scrollStart) / itemSize);
    }
  }

  return null;
};
//# sourceMappingURL=utils.js.map