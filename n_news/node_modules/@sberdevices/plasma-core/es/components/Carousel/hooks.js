import { useContext, useRef, useMemo, useEffect, useCallback } from 'react';
import throttle from 'lodash.throttle';
import { useDebouncedFunction } from '../../hooks';
import { CarouselContext } from './CarouselContext';
import { CarouselItemRefs } from './CarouselItemRefs';
import { scrollToPos, getCalculatedPos, getCalculatedOffset, getItemSlot } from './utils';
export var useCarouselContext = function useCarouselContext() {
  return useContext(CarouselContext);
};
/**
 * Хук для передачи рефа айтема в контекст карусели.
 */

export function useCarouselItem() {
  var innerRef = useRef(null);

  var _useCarouselContext = useCarouselContext(),
      refs = _useCarouselContext.refs;

  useEffect(function () {
    refs === null || refs === void 0 ? void 0 : refs.register(innerRef);
    return function () {
      return refs === null || refs === void 0 ? void 0 : refs.unregister(innerRef);
    };
  }, [refs]);
  return innerRef;
}
var THROTTLE_DEFAULT_MS = 100;
var DEBOUNCE_DEFAULT_MS = 150;
export var useCarousel = function useCarousel(_ref) {
  var index = _ref.index,
      axis = _ref.axis,
      _ref$detectActive = _ref.detectActive,
      detectActive = _ref$detectActive === void 0 ? false : _ref$detectActive,
      _ref$detectThreshold = _ref.detectThreshold,
      detectThreshold = _ref$detectThreshold === void 0 ? 0.5 : _ref$detectThreshold,
      _ref$scrollAlign = _ref.scrollAlign,
      scrollAlign = _ref$scrollAlign === void 0 ? 'center' : _ref$scrollAlign,
      scaleCallback = _ref.scaleCallback,
      scaleResetCallback = _ref.scaleResetCallback,
      onScroll = _ref.onScroll,
      onIndexChange = _ref.onIndexChange,
      onDetectActiveItem = _ref.onDetectActiveItem,
      _ref$animatedScrollBy = _ref.animatedScrollByIndex,
      animatedScrollByIndex = _ref$animatedScrollBy === void 0 ? false : _ref$animatedScrollBy,
      _ref$throttleMs = _ref.throttleMs,
      throttleMs = _ref$throttleMs === void 0 ? THROTTLE_DEFAULT_MS : _ref$throttleMs,
      _ref$debounceMs = _ref.debounceMs,
      debounceMs = _ref$debounceMs === void 0 ? DEBOUNCE_DEFAULT_MS : _ref$debounceMs;
  var prevIndex = useRef(null);
  var direction = useRef(null);
  var offset = useRef(0);
  var refs = useMemo(function () {
    return new CarouselItemRefs();
  }, []);
  var scrollRef = useRef(null);
  var trackRef = useRef(null);
  /**
   * Для того, чтобы не спамить изменениями индекса.
   * Задержка дебаунса слегка больше, чем у тротлинга.
   * Таким образом, событие срабатывает при завершении скролла.
   */

  var debouncedOnIndexChange = useDebouncedFunction(function (i) {
    return onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(i);
  }, debounceMs);
  /**
   * Вычисление центрального элемента.
   * Подсчет: от 0 до 1, какое количество ширины/высоты
   * каждого элемента находится по центру скролла.
   */

  var detectActiveItem = useCallback(throttle(function () {
    if (!scrollRef.current || !trackRef.current || !detectActive) {
      return;
    }
    /**
     * Правая (или нижняя для Оу) граница элемента.
     */


    var itemEdge = offset.current;
    /**
     * Смещение (отрицательный или положительный отступ)
     * и размер карусели (для Ox - ширина, для Oy - высота).
     */

    var scrollPos = scrollRef.current[axis === 'x' ? 'scrollLeft' : 'scrollTop'];
    var scrollSize = scrollRef.current[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];
    /**
     * Граница скролла (видимой части).
     * Смещение + размер.
     */

    var scrollEdge = scrollPos + scrollSize;
    /**
     * Элементы перед, после и в видимой части.
     * перед [ ВИДИМЫЕ ] после
     */

    var prevItems = [];
    var nextItems = [];
    var count = 0;
    /**
     * Проходим по всему списку, суммируя ширины элементов,
     * пока не найдем один элемент, чей центр будет в центре карусели.
     */

    refs.items.forEach(function (itemRef, itemIndex) {
      if (!itemRef.current) {
        return;
      }
      /**
       * Для Ox - ширина, для Oy - высота.
       */


      var itemSize = itemRef.current[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];
      /**
       * Все элементы правее вьюпорта выпадают из процедуры.
       * Сравниваем по предыдущему элементу.
       * [ ... ] ...|n| <- Левый край элемента за пределами начала видимой части
       */

      if (itemEdge > scrollEdge) {
        if (scaleCallback && scaleResetCallback) {
          nextItems.push(itemRef.current);
        }

        return;
      }

      itemEdge += itemSize;
      /**
       * Все элементы левее вьюпорта выпадают из процедуры.
       * Сравниваем по текущему элементу.
       * Правый край элемента за пределами начала видимой части -> |p|... [ ... ]
       */

      if (scrollPos > itemEdge) {
        if (scaleCallback && scaleResetCallback) {
          prevItems.push(itemRef.current);
        }

        return;
      }

      var itemSlot = getItemSlot(itemIndex, itemEdge, itemSize, scrollPos, scrollSize, scrollAlign, prevIndex.current || 0, offset.current);

      if (itemSlot !== null) {
        if (detectThreshold && Math.abs(itemSlot) <= detectThreshold) {
          onDetectActiveItem === null || onDetectActiveItem === void 0 ? void 0 : onDetectActiveItem(itemIndex);
          debouncedOnIndexChange(itemIndex);
        }

        if (scaleCallback) {
          scaleCallback(itemRef.current, itemSlot);
          /**
           * Количество айтемов в видимой части.
           */

          count++;
        }
      }
    });

    if (scaleCallback && scaleResetCallback) {
      window.requestAnimationFrame(function () {
        if (direction.current) {
          if (nextItems.length) {
            nextItems.splice(0, count).forEach(function (elem) {
              return scaleCallback(elem, count);
            });

            if (nextItems.length) {
              nextItems.splice(0, count).forEach(function (elem) {
                return scaleResetCallback(elem);
              });
            }
          }
        } else if (prevItems.length) {
          var prItemsRev = prevItems.reverse();
          prItemsRev.splice(0, count).forEach(function (elem) {
            return scaleCallback(elem, count * -1);
          });

          if (prItemsRev.length) {
            prItemsRev.splice(0, count).forEach(function (elem) {
              return scaleResetCallback(elem);
            });
          }
        }
      });
    }
  }, throttleMs), [axis, scrollRef, onIndexChange]);
  /**
   * Обработчик скролла на DOM-узел.
   */

  var handleScroll = useCallback(function (event) {
    detectActiveItem();
    onScroll === null || onScroll === void 0 ? void 0 : onScroll(event);
  }, [detectActiveItem, onScroll]);
  /**
   * Прокрутка до нужной позиции индекса.
   */

  var toIndex = useCallback(function (i) {
    if (scrollRef.current && trackRef.current && refs.items.length && i >= 0) {
      scrollToPos({
        scrollEl: scrollRef.current,
        pos: getCalculatedPos({
          scrollEl: scrollRef.current,
          items: refs.items,
          axis: axis,
          index: i,
          offset: offset.current,
          scrollAlign: scrollAlign
        }),
        axis: axis,

        /**
         * Без анимации при переходе на другой конец списка
         */
        animated: animatedScrollByIndex && (prevIndex.current === null || Math.abs(i - prevIndex.current) !== refs.items.length - 1)
      });
      prevIndex.current = i;
    }
  }, []);
  /**
   * Операции на маунте/анмаунте компонента.
   * Здесь нужно сделать кешируемые вычисления,
   * Создать слушатели событи и т.п.
   */

  useEffect(function () {
    if (scrollRef.current && trackRef.current) {
      offset.current = getCalculatedOffset(scrollRef.current, trackRef.current, axis);
      setTimeout(function () {
        /**
         * Прокрутка до начального индекса.
         */
        toIndex(index);
        /**
         * Если на момент запуска карусель уже находится на нужной позиции,
         * событие скролла не произойдет, не сработает и определение центра,
         * необходимо вызвать его вручную.
         */

        detectActiveItem();
      });
    }
  }, []);
  /**
   * Прокрутка до нужной позиции индекса, если индекс изменился.
   */

  useEffect(function () {
    if (index !== prevIndex.current) {
      toIndex(index);
    }
  }, [index]);
  return {
    scrollRef: scrollRef,
    trackRef: trackRef,
    refs: refs,
    handleScroll: handleScroll
  };
};
//# sourceMappingURL=hooks.js.map