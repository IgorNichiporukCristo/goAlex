import { ActionCommand } from '@salutejs/scenario';
import { AppInfo, AssistantAppState, AssistantSmartAppData, AssistantSmartAppError, AssistantStartSmartSearch, VpsConfiguration, EmotionId, OriginalMessageType, SystemMessageDataType, AssistantBackgroundApp, AssistantMeta, AssistantCommand, HistoryMessages, AdditionalMeta, Status, AssistantServerActionMode } from '../typings';
import { ProtocolError } from './client/protocol';
import { CreateTransportParams } from './client/transport';
import { TtsEvent } from './voice/voice';
import { VoiceListenerStatus } from './voice/listener/voiceListener';
import { MetaStringified } from './client/methods';
export declare type AppEvent = {
    type: 'run';
    app: AppInfo;
} | {
    type: 'close';
    app: AppInfo;
} | {
    type: 'command';
    app: AppInfo;
    command: AssistantSmartAppData | AssistantSmartAppError | AssistantStartSmartSearch;
};
export declare type AssistantEvent = {
    asr?: {
        text: string;
        last?: boolean;
        mid?: OriginalMessageType['messageId'];
    };
    /**
     * @deprecated Use the `on('assistant', { listener })` and `on('tts', tts)` subscriptions to receive voice events
     */
    emotion?: EmotionId;
    listener?: {
        status: VoiceListenerStatus;
    };
};
export declare type VpsEvent = {
    type: 'ready';
} | {
    type: 'error';
    error: Event | Error | undefined;
} | {
    type: 'outcoming';
    message: OriginalMessageType;
} | {
    type: 'incoming';
    systemMessage: SystemMessageDataType;
    originalMessage: OriginalMessageType;
};
export declare type ActionCommandEvent = {
    type: 'command';
    command: ActionCommand;
    appInfo: AppInfo;
};
export declare type AssistantError = ProtocolError;
export declare type AssistantEvents = {
    app: (event: AppEvent) => void;
    assistant: (event: AssistantEvent) => void;
    vps: (event: VpsEvent) => void;
    actionCommand: (event: ActionCommandEvent) => void;
    command: (command: AssistantCommand) => void;
    status: (status: Status) => void;
    error: (error: AssistantError) => void;
    history: (history: HistoryMessages[]) => void;
    tts: (event: TtsEvent) => void;
};
export interface CreateAssistantDevOptions {
    getMeta?: () => Record<string, unknown>;
    getInitialMeta?: () => Promise<Record<string, unknown>>;
}
declare type BackgroundAppOnCommand<T> = (command: (AssistantSmartAppData & {
    smart_app_data?: T;
}) | AssistantSmartAppError | AssistantStartSmartSearch, messageId: string) => void;
export declare type AssistantSettings = {
    /** Отключение фичи воспроизведения голоса */
    disableDubbing: boolean;
    /** Отключение фичи слушания речи */
    disableListening: boolean;
    /** Отправка текстовых сообщений с type: application/ssml */
    sendTextAsSsml: boolean;
};
export declare const createAssistant: ({ getMeta, getInitialMeta, checkCertUrl, ...configuration }: VpsConfiguration & CreateAssistantDevOptions & Pick<CreateTransportParams, 'checkCertUrl'>) => {
    readonly activeApp: AppInfo | null;
    readonly settings: any;
    destroy: () => void;
    closeApp: (closing?: AppInfo) => void;
    listen: ({ begin }?: {
        begin?: ArrayBuffer[] | undefined;
    }, isAutoListening?: boolean) => Promise<void>;
    sendServerAction: (serverAction: unknown, messageName?: string, requestId?: string | undefined, actionApp?: AppInfo, mode?: AssistantServerActionMode | undefined) => void;
    getHistoryRequest: (data?: import("../proto").IChatHistoryRequest & {
        history?: import("../typings").GetHistoryRequestClient | undefined;
    }) => void;
    sendText: (text: string, shouldSendDisableDubbing?: boolean, additionalMeta?: AdditionalMeta | undefined) => void;
    start: ({ disableGreetings, initPhrase, isFirstSession, }?: {
        /** Отключение приветственного сообщения при старте */
        disableGreetings?: boolean | undefined;
        initPhrase?: string | undefined;
        isFirstSession?: boolean | undefined;
    }) => Promise<SystemMessageDataType | undefined>;
    stop: () => void;
    stopTts: () => void;
    stopVoice: () => void;
    emit: <K extends keyof AssistantEvents>(event: K, ...args: Parameters<AssistantEvents[K]>) => void;
    on: <K_1 extends keyof AssistantEvents>(event: K_1, cb: AssistantEvents[K_1]) => () => void;
    changeConfiguration: (obj: Omit<Partial<{
        userId: string;
        token: string;
        userChannel: string;
        messageName: string | undefined;
        vpsToken: string | undefined;
        version: import("../typings").VpsVersion;
    } | {
        token: string;
        messageName: string | undefined;
        version: import("../typings").VpsVersion;
        userId?: undefined;
        userChannel?: undefined;
        vpsToken?: undefined;
    }>, "token">) => void;
    changeSettings: (object: Partial<{
        disableDubbing: boolean;
        disableListening: boolean;
        sendTextAsSsml: boolean;
    }>) => void;
    changeSdkMeta: (nextSdkMeta: Partial<AssistantMeta>) => void;
    reconnect: () => void;
    readonly protocol: {
        clearQueue: () => void;
        destroy: () => void;
        on: <K_2 extends keyof import("./client/protocol").ProtocolEvents>(event: K_2, cb: import("./client/protocol").ProtocolEvents[K_2]) => () => void;
        getHistoryRequest: (data?: import("../proto").IChatHistoryRequest & {
            history?: import("../typings").GetHistoryRequestClient | undefined;
        }) => void;
        getMessageId: () => number;
        sendCancel: (data: import("../proto").ICancel, last?: boolean, messageId?: number) => void;
        sendText: (data: string, params?: {
            messageId?: number | undefined;
            last?: 1 | -1 | undefined;
            messageName?: string | undefined;
            vpsToken?: string | undefined;
            userId?: string | undefined;
            token?: string | undefined;
            userChannel?: string | undefined;
            version?: import("../typings").VpsVersion | undefined;
            meta?: MetaStringified | undefined;
        }, type?: string, messageId?: number) => void;
        sendSystemMessage: ({ data, messageName: mesName }: {
            data: Record<string, unknown>;
            messageName?: string | undefined;
        }, last?: boolean, messageId?: number, params?: {
            meta?: MetaStringified | undefined;
        }) => void;
        sendVoice: (data: Uint8Array, last?: boolean, messageId?: number, mesName?: string | undefined, params?: {
            meta?: MetaStringified | undefined;
        }) => void;
        send: (message: import("../proto").IMessage) => void;
        batch: <T>(cb: (methods: import("./client/methods").BatchableMethods) => T) => T;
        changeConfiguration: (obj: Omit<Partial<{
            userId: string;
            token: string;
            userChannel: string;
            messageName: string | undefined;
            vpsToken: string | undefined;
            version: import("../typings").VpsVersion;
        } | {
            token: string;
            messageName: string | undefined;
            version: import("../typings").VpsVersion;
            userId?: undefined;
            userChannel?: undefined;
            vpsToken?: undefined;
        }>, "token">) => void;
        changeDevice: (obj: Partial<import("../proto").IDevice | undefined>) => void;
        changeSettings: (obj: Partial<import("../proto").ISettings>) => void;
        reconnect: () => void;
        init: () => Promise<void>;
        readonly currentMessageId: number;
        readonly configuration: {
            token: string;
            url: string;
            userId: string;
            userChannel: string;
            locale?: string | undefined;
            device?: import("../proto").IDevice | undefined;
            settings: import("../proto").ISettings;
            fakeVps?: import("../typings").FakeVpsParams | undefined;
            legacyDevice?: import("../proto").ILegacyDevice | undefined;
            version: import("../typings").VpsVersion;
            messageName?: string | undefined;
            vpsToken?: string | undefined;
        };
        readonly status: "ready" | "connecting" | "connected" | "closed";
    };
    setActiveApp: (info: AppInfo, getState?: (() => Promise<AssistantAppState>) | undefined) => void;
    addBackgroundApp: ({ appInfo, getState }: AssistantBackgroundApp) => {
        remove: () => void;
        onCommand: <T_1>(subscriber: BackgroundAppOnCommand<T_1>) => {
            clearSubscribers: () => void;
        };
        sendServerAction: (serverAction: unknown, messageName?: string, requestId?: string | undefined) => void;
    };
    readonly status: "ready" | "connecting" | "connected" | "closed";
};
export {};
//# sourceMappingURL=assistant.d.ts.map